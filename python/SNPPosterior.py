'''Crude approximate posterior distribution used for initial choice of
most informative peaks on each strand for each site/sample pair.'''

import scipy, scipy.stats, cPickle, os

from Dirichlet import Dirichlet
from sequences import reverse_complement
from Peak import binlocs, Peak
from datadir import datadir

# Get the ENCODE genotype frequencies
nullpath = os.path.join(datadir, 'genotype_frequencies.pickle')
nullprobs = cPickle.load(open(nullpath))

# Single-peak probabilities

# ...generated by encode_hapmap_concordances_full_counts.py
allcounts = cPickle.load(open(os.path.join(datadir, 'raw_counts.pickle')))

# Collect these counts into bins
scorebins = scipy.array([0]+list(reversed(range(60, 10, -10))))
nscores = len(scorebins)
binlocs = scipy.zeros(69)
for binidx, (start, end) in enumerate(
    zip(scorebins, list(scorebins[1:])+[len(binlocs)])):
    for score in range(start, end):
        binlocs[score] = binidx

nukes = 'ACGT'
# List of possible genotypes
pcalls = sorted(set(n1+n2 for n1 in nukes for n2 in nukes
                   if n1 <= n2))
callidxs = dict((g, i) for i, g in enumerate(pcalls))
# Map to reverse complements
revcalls = [''.join(sorted(reverse_complement(n)))
            for n in pcalls]
# List of possible observed peaks
ppeaks=sorted(set(nukes).union(set(g for g in pcalls if g[0] != g[1])))
peakidxs = dict((p, i) for i, p in enumerate(ppeaks))
revpeaks = [''.join(sorted(reverse_complement(n)))
            for n in ppeaks]

# Pseudocounts  for  score bins,  given  an  actual  genotype and  the
# observed peaks.  Structure is {actual: {observed: [scores]}}
scorepseudos = dict(
    (g, dict((p, scipy.ones((nscores,)*len(p),'i'))
             for p in ppeaks))
     for g in pcalls)
# Pseudocounts for observed peaks, given an actual genotype.
peakpseudos = dict((g, scipy.ones(len(ppeaks), 'i')) for g in pcalls)

for genotype, counts in allcounts.items():
    for peaks, pcount in counts.items():
        peaknukes, peakscores = peaks[0], peaks[1:]
        # If it's "homozygous", just make it the single peak
        peaknukes = ''.join(sorted(set(peaknukes)))
        if len(set(genotype)) > len(peaknukes):
            # A heterozygous  site turning  into a single  peak.  This
            # confounds the statistics, so remove it.
            continue
        peakpseudos[genotype][peakidxs[peaknukes]] += pcount
        peakbins = tuple(binlocs[score] for score in peakscores)
        scorepseudos[genotype][peaknukes][peakbins] += pcount

class PeakModel:

    """Representation  of  the probability  model  for observed  peaks
    given  actual  genotypes.   On  instantiation,  probabilities  are
    sampled from the pseudocounts just computed."""

    scorepseudos = dict(
        (g, dict((p,  Dirichlet(c.flatten()))
                 for p, c in peaks.items()))
         for g, peaks in scorepseudos.items())
    peakpseudos = dict((g, Dirichlet(c))
                       for g, c in peakpseudos.items())

    def __init__(self, genprior=nullprobs):
        self.genprior = genprior
        self.scoreprobs = {}
        for genotype, peakpriors in self.scorepseudos.items():
            self.scoreprobs[genotype] = cprobs = {}
            for peaks, prior in peakpriors.items():
                # At  some point,  may want  to actually  sample here.
                # There are  tonnes of data  in the calls  I'm making,
                # after all.
                probs = prior.mean()
                dim = 1 if len(probs) == nscores else 2
                cprobs[peaks] = scipy.reshape(
                    probs, (nscores,)*dim)
        self.peakprobs = dict(
            (g, p.mean()) for g, p in self.peakpseudos.items())
        self.posteriors = {}
        for peaks in ppeaks:
            peakidx = peakidxs[peaks]
            dim = len(peaks)
            self.posteriors[peaks] = scipy.zeros(
                dim*(nscores,) + (len(pcalls),), 'f')
            indxs=zip(*[i.flatten() for i in scipy.indices((6,)*dim)])
            for binidx in indxs:
                total = 0
                for gi, g in enumerate(pcalls):
                    prob = (self.genprior[g]*
                            self.peakprobs[g][peakidx]*
                            self.scoreprobs[g][peaks][binidx])
                    self.posteriors[peaks][binidx][gi] = prob
                    total += prob
                assert total != 0
                self.posteriors[peaks][binidx] /= total

peakposteriors = PeakModel().posteriors

class PostPeak(Peak):

    def gendist(self):
        return peakposteriors[self.peaks][self.bin]
    
# Memoize the score/call relationship
bytescores = [PostPeak(byte=byte) for byte in xrange(240)]
rawscores  = dict(
    ((c.peaks, c.bin), byte) for byte, c in enumerate(bytescores))
# Memoize which bytes correspond to reverse complements
revscores = scipy.zeros(240, 'B')
for byte, score in enumerate(bytescores):
    if score.double:
        score = sorted(zip(map(reverse_complement, score.peaks),
                           score.bin))
        revscores[byte] = rawscores[''.join(t[0] for t in score),
                                    tuple(t[1] for t in score)]
    else:
        revscores[byte] = rawscores[reverse_complement(score.peaks),
                                    score.bin]

dists = scipy.array([s.gendist() for s in bytescores])
entropies = scipy.array(map(scipy.stats.entropy, dists))
colents = scipy.array([entropies]*len(bytescores))
rowents = scipy.transpose(colents)

# Memo of the most informative scores for each pair
# Zero means the first, one means the second
infomemo = scipy.argmin(scipy.array([rowents, colents]), 0)

def choose_best(*bytes):
    """Choose the  score with the most information  content, given the
    posteriors computed above."""
    if 255 in bytes:
        # One of the peaks is undefined, return the other by default
        return min(bytes)
    return bytes[infomemo[bytes]]
